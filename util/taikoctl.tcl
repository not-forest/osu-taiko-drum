#!/usr/bin/env tclsh9.0
###
### Taiko Drum Controller configuration utility.
###
### Communicates with drum's firmware via USB serial interface by sending raw commands, which are afterwards parsed 
### by the microcontroller. This utility does not checks the endpoint device for proper VID,PID values, therefore
### higher level software is required to find a proper file created by the OS (e.g. ttyACM0, COM1, etc.) while enumerating 
### the USB device.

set version "0.1.0"
array set config {}
set port ""
set cmd ""

# Utility help message.
proc help {} {
    puts "Taiko Drum Controller Configuration Utility"
    puts ""
    puts "Usage:"
    puts "  taikoctl --port <device> \[options\]"
    puts ""
    puts "Required:"
    puts "  --port, -p         Serial port (e.g. COM3, /dev/ttyUSB0)"
    puts ""
    puts "Options:"
    puts "  --configure, -c    Configuration string to send to the device"
    puts "                    e.g. \"left_don=X right_kat=V\""
    puts "  Valid configuration values:"
    puts "  left_don, right_don, left_kat, right_kat"
    puts "  --reset            Resets the firmware."
    puts "  --read -r          Read current configuration from the device. This option is set as default if no configuration is provided."
    puts "  --help, -h         Show this help message"
    puts "  --version, -v      Shows current version of this utility. The version will always match the current firmware version."
    puts ""
    puts "Examples:"
    puts "  taikoctl --port /dev/ttyUSB0 --configure \"left_don=X\""
    puts "  taikoctl --port COM3 --read"
}

# Args
set i 0
while {$i < [llength $argv]} {
    set key [lindex $argv $i]
    incr i

    switch -- $key {
        -p { set key --port         }
        -c { set key --configure    }
        -r { set key --read         }
        -h { set key --help         }
        -v { set key --version      }
    }

    switch -- $key {
        --port -
        --configure {
            if {$i >= [llength $argv]} {
                puts stderr "Missing value for $key"
                exit 1
            }
            set val [lindex $argv $i]
            incr i
        }

        --read {
            if {$cmd eq ""} {
                set cmd read
            } else {
                puts "Invalid command merging. Some arguments collide with each other."
                exit 1
            }
            continue
        }

        --reset {
            if {$cmd eq ""} {
                set cmd reset
            } else {
                puts "Invalid command merging. Some arguments collide with each other."
                exit 1
            }
            continue
        }

        --version {
            puts "Version: ${version}"
            exit 0
        }

        --help {
            help
            exit 0
        }

        default {
            puts stderr "Unknown argument: $key"
            help
            exit 1
        }
    }

    switch -- $key {
        --port      { set port $val }
        --configure {
            # Parses the configuration string into an array
            if {[string length $val] > 0} {
                set cmd write
                set keys "left_kat right_kat left_don right_don sens sharp"
                foreach pair [split $val " "] {
                    set split_pair [split $pair "="]
                    set key [lindex $split_pair 0]
                    set value [lindex $split_pair 1]
            
                    if {[string match "*${key}*" $keys]} {
                        set config($key) $value
                    } else {
                        puts stderr "Invalid configuration value ${key}. See --help for more information."
                        exit 1
                    }
                }
            }
        }
    }
}


if {$argv eq "" || $cmd eq ""} {
    puts stderr "Error: Invalid usage. See --help for more information."
    exit 1
}
if {$port eq ""} {
    puts stderr "Error: --port must be specified"
    exit 1
}

# Command bytes definition. Those are equal to the ones defined within the drum's firmware.
set CMD_READ    0x01
set CMD_WRITE   0x02
set RESERVED    0x03

set CMD_RESET   0xFF
set ACK         0x06

array set key_to_cmd {
    left_kat  0x10
    left_don  0x11
    right_don 0x12
    right_kat 0x13

    sens      0x20
    sharp     0x21
}

# Opens and configures the requested serial port.
#
# @param port
#       proper channel that will be used for reading/writing data. It shall be a proper serial 
#       port interface generated by Taiko Drum Firmware device.
proc serial {port} {
    if { [catch { set serial [open $port {RDWR NONBLOCK}] } err] } {
        puts stderr "Failed to open $port: $err"
        exit 1
    }

    chan configure $serial -buffering none -translation binary
    return $serial
}

# Waits for a specific byte from the serial port.
#
# @param serial
#       Opened and configured serial from which we expect the required byte.
# @param expected_byte
#       The expected byte value.
# @param timeout
#       Amount in seconds, after which the script shall give up the connection.
proc wait_for {serial expected_byte timeout} {
    set start_time [clock seconds]
    while {1} {
        set byte [read $serial 1]
        if {[binary scan $byte c received] && $received == $expected_byte} {
            return 1
        }
        
        set current_time [clock seconds]
        if {($current_time - $start_time) >= $timeout} {
            return 0
        }
        
        after 10
    }
}

proc byte {val} { binary format c $val }

# Waiting for ACK from the microcontroller's side with timeout of 5 seconds.
proc until_ack {conn ack timeout} {
    if {![wait_for $conn $ack $timeout]} {
        puts stderr "Did not receive ACK from device (timeout)."
        exit 1
    }
}

# Main

set conn [serial $port]
set timeout 5

if {$cmd eq "read"} {
    puts -nonewline $conn [byte $CMD_READ]
    flush $conn

    until_ack $conn $ACK $timeout

    # Read each configuration entry: 2 bytes per item
    set received_config ""
    while {[eof $conn] eq 0} {
        set cmd_byte [read $conn 1]

        if {[string length $cmd_byte] < 1} {
            break
        }
        binary scan $cmd_byte c cmd_id

        # Backward keyname unparsing.
        set key "UNKNOWN"
        set raw_value 0xFF
        foreach k [array names key_to_cmd] {
            if {$key_to_cmd($k) == $cmd_id} {
                set key $k
                break
            }
        }

        switch $key {
            "sens" {
                set raw_value [read $conn 4]
                binary scan $raw_value I val
            }
            "sharp" {
                set raw_value [read $conn 2]
                binary scan $raw_value S val
            }
            default {
                set raw_value [read $conn 1]
                binary scan $raw_value cu val
            }
        }

        append received_config "$key=[format %u $val] "
    }

    puts "Received: $received_config"

} elseif {$cmd eq "write"} {
    set len 0
    puts -nonewline $conn [byte $CMD_WRITE]
    flush $conn
    until_ack $conn $ACK $timeout 

    foreach key [array names config] {
        if {![info exists key_to_cmd($key)]} {
            puts stderr "Unknown config key: $key"
            exit 1 
        }
    }

    set msg ""
    # Sends all configuration values in key-value pairs.
    foreach key [array names config] {
        set cmd_byte [byte $key_to_cmd($key)]
        set value $config($key)

        switch $key {
            "sens" {
                set val_bytes [binary format I $value]
                incr len 5
            }
            "sharp" {
                set val_bytes [binary format S $value]
                incr len 3
            }
            default {
                set val_bytes [binary format c $value]
                incr len 2
            }
        }

        append msg "${cmd_byte}${val_bytes}"
    } 
    puts -nonewline $conn msg
    flush $conn

    puts "Configuration of ${len} bytes is sent."
} elseif {$cmd eq "reset"} {
    puts -nonewline $conn [byte $CMD_RESET]
    flush $conn
    until_ack $conn $ACK $timeout
}
